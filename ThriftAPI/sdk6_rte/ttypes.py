#
# Autogenerated by Thrift Compiler (0.15.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class RteReturnValue(object):
    """
    ************************************************************
     Global structures/defines                                  *
    ************************************************************

    """
    SUCCESS = 0
    QUALIFIED = 1
    ARGINVALID = 2
    IOERROR = 3
    MEMORYERROR = 4
    FILEIOERROR = 5
    NOTLOADED = 6
    HWINCOMPATIBLE = 7

    _VALUES_TO_NAMES = {
        0: "SUCCESS",
        1: "QUALIFIED",
        2: "ARGINVALID",
        3: "IOERROR",
        4: "MEMORYERROR",
        5: "FILEIOERROR",
        6: "NOTLOADED",
        7: "HWINCOMPATIBLE",
    }

    _NAMES_TO_VALUES = {
        "SUCCESS": 0,
        "QUALIFIED": 1,
        "ARGINVALID": 2,
        "IOERROR": 3,
        "MEMORYERROR": 4,
        "FILEIOERROR": 5,
        "NOTLOADED": 6,
        "HWINCOMPATIBLE": 7,
    }


class RteValueType(object):
    Invalid = 0
    Int64 = 1
    String = 2

    _VALUES_TO_NAMES = {
        0: "Invalid",
        1: "Int64",
        2: "String",
    }

    _NAMES_TO_VALUES = {
        "Invalid": 0,
        "Int64": 1,
        "String": 2,
    }


class LogLevel(object):
    """
    ************************************************************
     Defines for general functions                              *
    ************************************************************

    """
    Unknown = 0
    Disable = 1
    Fatal = 2
    Error = 3
    Warn = 4
    Info = 5
    Debug = 6
    Extra = 7
    Heavy = 8

    _VALUES_TO_NAMES = {
        0: "Unknown",
        1: "Disable",
        2: "Fatal",
        3: "Error",
        4: "Warn",
        5: "Info",
        6: "Debug",
        7: "Extra",
        8: "Heavy",
    }

    _NAMES_TO_VALUES = {
        "Unknown": 0,
        "Disable": 1,
        "Fatal": 2,
        "Error": 3,
        "Warn": 4,
        "Info": 5,
        "Debug": 6,
        "Extra": 7,
        "Heavy": 8,
    }


class RegisterType(object):
    Invalid = 0
    Global = 1
    Direct = 2
    Static = 3

    _VALUES_TO_NAMES = {
        0: "Invalid",
        1: "Global",
        2: "Direct",
        3: "Static",
    }

    _NAMES_TO_VALUES = {
        "Invalid": 0,
        "Global": 1,
        "Direct": 2,
        "Static": 3,
    }


class P4CounterType(object):
    """
    ************************************************************
     Structure for Counters                                     *
    ************************************************************

    """
    Invalid = 0
    Global = 1
    Direct = 2
    Static = 3

    _VALUES_TO_NAMES = {
        0: "Invalid",
        1: "Global",
        2: "Direct",
        3: "Static",
    }

    _NAMES_TO_VALUES = {
        "Invalid": 0,
        "Global": 1,
        "Direct": 2,
        "Static": 3,
    }


class MeterType(object):
    """
    ************************************************************
     Meters                                                     *
    ************************************************************

    """
    Invalid = 0
    Global = 1
    Direct = 2
    Static = 3

    _VALUES_TO_NAMES = {
        0: "Invalid",
        1: "Global",
        2: "Direct",
        3: "Static",
    }

    _NAMES_TO_VALUES = {
        "Invalid": 0,
        "Global": 1,
        "Direct": 2,
        "Static": 3,
    }


class MeterClass(object):
    Invalid = 0
    Packets = 1
    Bytes = 2

    _VALUES_TO_NAMES = {
        0: "Invalid",
        1: "Packets",
        2: "Bytes",
    }

    _NAMES_TO_VALUES = {
        "Invalid": 0,
        "Packets": 1,
        "Bytes": 2,
    }


class RteReturn(object):
    """
    Attributes:
     - value
     - reason

    """


    def __init__(self, value=None, reason=None,):
        self.value = value
        self.reason = reason

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reason = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RteReturn')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 1)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.reason is not None:
            oprot.writeFieldBegin('reason', TType.STRING, 2)
            oprot.writeString(self.reason.encode('utf-8') if sys.version_info[0] == 2 else self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RteValue(object):
    """
    Attributes:
     - type
     - stringval
     - intval

    """


    def __init__(self, type=None, stringval=None, intval=None,):
        self.type = type
        self.stringval = stringval
        self.intval = intval

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.stringval = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.intval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RteValue')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.stringval is not None:
            oprot.writeFieldBegin('stringval', TType.STRING, 2)
            oprot.writeString(self.stringval.encode('utf-8') if sys.version_info[0] == 2 else self.stringval)
            oprot.writeFieldEnd()
        if self.intval is not None:
            oprot.writeFieldBegin('intval', TType.I64, 3)
            oprot.writeI64(self.intval)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DesignLoadArgs(object):
    """
    ************************************************************
     Structure for design load/unload/reload                    *
    ************************************************************

    Attributes:
     - nfpfw
     - pif_design_json
     - pif_config_json

    """


    def __init__(self, nfpfw=None, pif_design_json=None, pif_config_json=None,):
        self.nfpfw = nfpfw
        self.pif_design_json = pif_design_json
        self.pif_config_json = pif_config_json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nfpfw = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pif_design_json = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pif_config_json = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DesignLoadArgs')
        if self.nfpfw is not None:
            oprot.writeFieldBegin('nfpfw', TType.STRING, 1)
            oprot.writeBinary(self.nfpfw)
            oprot.writeFieldEnd()
        if self.pif_design_json is not None:
            oprot.writeFieldBegin('pif_design_json', TType.STRING, 2)
            oprot.writeBinary(self.pif_design_json)
            oprot.writeFieldEnd()
        if self.pif_config_json is not None:
            oprot.writeFieldBegin('pif_config_json', TType.STRING, 3)
            oprot.writeBinary(self.pif_config_json)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.nfpfw is None:
            raise TProtocolException(message='Required field nfpfw is unset!')
        if self.pif_design_json is None:
            raise TProtocolException(message='Required field pif_design_json is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DesignLoadStatus(object):
    """
    Attributes:
     - is_loaded
     - uuid
     - frontend_build_date
     - frontend_source
     - frontend_version
     - uptime

    """


    def __init__(self, is_loaded=None, uuid=None, frontend_build_date=None, frontend_source=None, frontend_version=None, uptime=None,):
        self.is_loaded = is_loaded
        self.uuid = uuid
        self.frontend_build_date = frontend_build_date
        self.frontend_source = frontend_source
        self.frontend_version = frontend_version
        self.uptime = uptime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_loaded = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.frontend_build_date = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.frontend_source = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.frontend_version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.uptime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DesignLoadStatus')
        if self.is_loaded is not None:
            oprot.writeFieldBegin('is_loaded', TType.BOOL, 1)
            oprot.writeBool(self.is_loaded)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 2)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        if self.frontend_build_date is not None:
            oprot.writeFieldBegin('frontend_build_date', TType.STRING, 3)
            oprot.writeString(self.frontend_build_date.encode('utf-8') if sys.version_info[0] == 2 else self.frontend_build_date)
            oprot.writeFieldEnd()
        if self.frontend_source is not None:
            oprot.writeFieldBegin('frontend_source', TType.STRING, 4)
            oprot.writeString(self.frontend_source.encode('utf-8') if sys.version_info[0] == 2 else self.frontend_source)
            oprot.writeFieldEnd()
        if self.frontend_version is not None:
            oprot.writeFieldBegin('frontend_version', TType.STRING, 5)
            oprot.writeString(self.frontend_version.encode('utf-8') if sys.version_info[0] == 2 else self.frontend_version)
            oprot.writeFieldEnd()
        if self.uptime is not None:
            oprot.writeFieldBegin('uptime', TType.I64, 6)
            oprot.writeI64(self.uptime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_loaded is None:
            raise TProtocolException(message='Required field is_loaded is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RegisterArrayArg(object):
    """
    ************************************************************
     Structure for Register                                     *
    ************************************************************

    Attributes:
     - reg_id
     - index
     - count

    """


    def __init__(self, reg_id=None, index=None, count=None,):
        self.reg_id = reg_id
        self.index = index
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reg_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RegisterArrayArg')
        if self.reg_id is not None:
            oprot.writeFieldBegin('reg_id', TType.I32, 1)
            oprot.writeI32(self.reg_id)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 2)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RegisterFieldDesc(object):
    """
    Attributes:
     - name
     - width

    """


    def __init__(self, name=None, width=None,):
        self.name = name
        self.width = width

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RegisterFieldDesc')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I32, 2)
            oprot.writeI32(self.width)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RegisterDesc(object):
    """
    Attributes:
     - name
     - id
     - type
     - count
     - table
     - tableid
     - fields

    """


    def __init__(self, name=None, id=None, type=None, count=None, table=None, tableid=None, fields=None,):
        self.name = name
        self.id = id
        self.type = type
        self.count = count
        self.table = table
        self.tableid = tableid
        self.fields = fields

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.tableid = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.fields = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = RegisterFieldDesc()
                        _elem5.read(iprot)
                        self.fields.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RegisterDesc')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 2)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 4)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 5)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.tableid is not None:
            oprot.writeFieldBegin('tableid', TType.I32, 6)
            oprot.writeI32(self.tableid)
            oprot.writeFieldEnd()
        if self.fields is not None:
            oprot.writeFieldBegin('fields', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.fields))
            for iter6 in self.fields:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class P4CounterDesc(object):
    """
    Attributes:
     - name
     - id
     - type
     - count
     - table
     - tableid
     - width

    """


    def __init__(self, name=None, id=None, type=None, count=None, table=None, tableid=None, width=None,):
        self.name = name
        self.id = id
        self.type = type
        self.count = count
        self.table = table
        self.tableid = tableid
        self.width = width

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.tableid = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('P4CounterDesc')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 2)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 4)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 5)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.tableid is not None:
            oprot.writeFieldBegin('tableid', TType.I32, 6)
            oprot.writeI32(self.tableid)
            oprot.writeFieldEnd()
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I32, 7)
            oprot.writeI32(self.width)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SysCounterValue(object):
    """
    Attributes:
     - name
     - id
     - value

    """


    def __init__(self, name=None, id=None, value=None,):
        self.name = name
        self.id = id
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.value = RteValue()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SysCounterValue')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 2)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 3)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class P4CounterReturn(object):
    """
    Attributes:
     - data
     - count

    """


    def __init__(self, data=None, count=None,):
        self.data = data
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('P4CounterReturn')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableEntry(object):
    """
    ************************************************************
     Structure for Table Entry Modification                     *
    ************************************************************

    Attributes:
     - rule_name
     - default_rule
     - match
     - actions
     - priority

    """


    def __init__(self, rule_name=None, default_rule=None, match=None, actions=None, priority=None,):
        self.rule_name = rule_name
        self.default_rule = default_rule
        self.match = match
        self.actions = actions
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.rule_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.default_rule = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.match = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.actions = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableEntry')
        if self.rule_name is not None:
            oprot.writeFieldBegin('rule_name', TType.STRING, 1)
            oprot.writeString(self.rule_name.encode('utf-8') if sys.version_info[0] == 2 else self.rule_name)
            oprot.writeFieldEnd()
        if self.default_rule is not None:
            oprot.writeFieldBegin('default_rule', TType.BOOL, 2)
            oprot.writeBool(self.default_rule)
            oprot.writeFieldEnd()
        if self.match is not None:
            oprot.writeFieldBegin('match', TType.STRING, 3)
            oprot.writeBinary(self.match)
            oprot.writeFieldEnd()
        if self.actions is not None:
            oprot.writeFieldBegin('actions', TType.STRING, 4)
            oprot.writeBinary(self.actions)
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 5)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.rule_name is None:
            raise TProtocolException(message='Required field rule_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableDesc(object):
    """
    Attributes:
     - tbl_id
     - tbl_name
     - tbl_entries_max

    """


    def __init__(self, tbl_id=None, tbl_name=None, tbl_entries_max=None,):
        self.tbl_id = tbl_id
        self.tbl_name = tbl_name
        self.tbl_entries_max = tbl_entries_max

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tbl_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.tbl_entries_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableDesc')
        if self.tbl_id is not None:
            oprot.writeFieldBegin('tbl_id', TType.I32, 1)
            oprot.writeI32(self.tbl_id)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.tbl_entries_max is not None:
            oprot.writeFieldBegin('tbl_entries_max', TType.I32, 3)
            oprot.writeI32(self.tbl_entries_max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tbl_id is None:
            raise TProtocolException(message='Required field tbl_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class McastCfgEntry(object):
    """
    ************************************************************
     Multicast Group Configuration                              *
    ************************************************************

    Attributes:
     - group_id
     - max_entries
     - ports

    """


    def __init__(self, group_id=None, max_entries=None, ports=None,):
        self.group_id = group_id
        self.max_entries = max_entries
        self.ports = ports

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.group_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.max_entries = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.ports = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readI32()
                        self.ports.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('McastCfgEntry')
        if self.group_id is not None:
            oprot.writeFieldBegin('group_id', TType.I32, 1)
            oprot.writeI32(self.group_id)
            oprot.writeFieldEnd()
        if self.max_entries is not None:
            oprot.writeFieldBegin('max_entries', TType.I32, 2)
            oprot.writeI32(self.max_entries)
            oprot.writeFieldEnd()
        if self.ports is not None:
            oprot.writeFieldBegin('ports', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.ports))
            for iter13 in self.ports:
                oprot.writeI32(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PortInfo(object):
    """
    ************************************************************
     Port information                                            *
    ************************************************************

    Attributes:
     - id
     - token
     - info

    """


    def __init__(self, id=None, token=None, info=None,):
        self.id = id
        self.token = token
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.info = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PortInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeString(self.token.encode('utf-8') if sys.version_info[0] == 2 else self.token)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRING, 3)
            oprot.writeString(self.info.encode('utf-8') if sys.version_info[0] == 2 else self.info)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ParserValueSetFieldDesc(object):
    """
    ************************************************************
     Structure for Parser Value Sets                            *
    ************************************************************

    Attributes:
     - name
     - width

    """


    def __init__(self, name=None, width=None,):
        self.name = name
        self.width = width

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParserValueSetFieldDesc')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I32, 2)
            oprot.writeI32(self.width)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ParserValueSetEntry(object):
    """
    Attributes:
     - value
     - mask

    """


    def __init__(self, value=None, mask=None,):
        self.value = value
        self.mask = mask

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mask = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParserValueSetEntry')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.mask is not None:
            oprot.writeFieldBegin('mask', TType.STRING, 2)
            oprot.writeString(self.mask.encode('utf-8') if sys.version_info[0] == 2 else self.mask)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ParserValueSetDesc(object):
    """
    Attributes:
     - pvs_id
     - pvs_name
     - pvs_entries_max
     - key_layout

    """


    def __init__(self, pvs_id=None, pvs_name=None, pvs_entries_max=None, key_layout=None,):
        self.pvs_id = pvs_id
        self.pvs_name = pvs_name
        self.pvs_entries_max = pvs_entries_max
        self.key_layout = key_layout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.pvs_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pvs_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pvs_entries_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.key_layout = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = ParserValueSetFieldDesc()
                        _elem19.read(iprot)
                        self.key_layout.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParserValueSetDesc')
        if self.pvs_id is not None:
            oprot.writeFieldBegin('pvs_id', TType.I32, 1)
            oprot.writeI32(self.pvs_id)
            oprot.writeFieldEnd()
        if self.pvs_name is not None:
            oprot.writeFieldBegin('pvs_name', TType.STRING, 2)
            oprot.writeString(self.pvs_name.encode('utf-8') if sys.version_info[0] == 2 else self.pvs_name)
            oprot.writeFieldEnd()
        if self.pvs_entries_max is not None:
            oprot.writeFieldBegin('pvs_entries_max', TType.I32, 3)
            oprot.writeI32(self.pvs_entries_max)
            oprot.writeFieldEnd()
        if self.key_layout is not None:
            oprot.writeFieldBegin('key_layout', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.key_layout))
            for iter20 in self.key_layout:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pvs_id is None:
            raise TProtocolException(message='Required field pvs_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MeterCfg(object):
    """
    Attributes:
     - rate_k
     - burst_k
     - array_offset
     - count

    """


    def __init__(self, rate_k=None, burst_k=None, array_offset=None, count=None,):
        self.rate_k = rate_k
        self.burst_k = burst_k
        self.array_offset = array_offset
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.rate_k = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.burst_k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.array_offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MeterCfg')
        if self.rate_k is not None:
            oprot.writeFieldBegin('rate_k', TType.DOUBLE, 1)
            oprot.writeDouble(self.rate_k)
            oprot.writeFieldEnd()
        if self.burst_k is not None:
            oprot.writeFieldBegin('burst_k', TType.I32, 2)
            oprot.writeI32(self.burst_k)
            oprot.writeFieldEnd()
        if self.array_offset is not None:
            oprot.writeFieldBegin('array_offset', TType.I32, 3)
            oprot.writeI32(self.array_offset)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 4)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MeterDesc(object):
    """
    Attributes:
     - name
     - id
     - type
     - mclass
     - count
     - table
     - tableid

    """


    def __init__(self, name=None, id=None, type=None, mclass=None, count=None, table=None, tableid=None,):
        self.name = name
        self.id = id
        self.type = type
        self.mclass = mclass
        self.count = count
        self.table = table
        self.tableid = tableid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.mclass = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.tableid = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MeterDesc')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 2)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.mclass is not None:
            oprot.writeFieldBegin('mclass', TType.I32, 4)
            oprot.writeI32(self.mclass)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 5)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 6)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.tableid is not None:
            oprot.writeFieldBegin('tableid', TType.I32, 7)
            oprot.writeI32(self.tableid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DigestFieldDesc(object):
    """
    ************************************************************
     Digests                                                    *
    ************************************************************

    Attributes:
     - name
     - width

    """


    def __init__(self, name=None, width=None,):
        self.name = name
        self.width = width

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DigestFieldDesc')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I32, 2)
            oprot.writeI32(self.width)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DigestDesc(object):
    """
    Attributes:
     - name
     - id
     - app_id
     - field_list_name
     - fields

    """


    def __init__(self, name=None, id=None, app_id=None, field_list_name=None, fields=None,):
        self.name = name
        self.id = id
        self.app_id = app_id
        self.field_list_name = field_list_name
        self.fields = fields

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.field_list_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.fields = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = DigestFieldDesc()
                        _elem26.read(iprot)
                        self.fields.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DigestDesc')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 2)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        if self.field_list_name is not None:
            oprot.writeFieldBegin('field_list_name', TType.STRING, 4)
            oprot.writeString(self.field_list_name.encode('utf-8') if sys.version_info[0] == 2 else self.field_list_name)
            oprot.writeFieldEnd()
        if self.fields is not None:
            oprot.writeFieldBegin('fields', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.fields))
            for iter27 in self.fields:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DebugCtlReturn(object):
    """
    ************************************************************
     Opaque debug interface                                     *
    ************************************************************

    Attributes:
     - return_value
     - return_data

    """


    def __init__(self, return_value=None, return_data=None,):
        self.return_value = return_value
        self.return_data = return_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.return_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.return_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DebugCtlReturn')
        if self.return_value is not None:
            oprot.writeFieldBegin('return_value', TType.I32, 1)
            oprot.writeI32(self.return_value)
            oprot.writeFieldEnd()
        if self.return_data is not None:
            oprot.writeFieldBegin('return_data', TType.STRING, 2)
            oprot.writeBinary(self.return_data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RteReturn)
RteReturn.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'value', None, None, ),  # 1
    (2, TType.STRING, 'reason', 'UTF8', None, ),  # 2
)
all_structs.append(RteValue)
RteValue.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRING, 'stringval', 'UTF8', None, ),  # 2
    (3, TType.I64, 'intval', None, None, ),  # 3
)
all_structs.append(DesignLoadArgs)
DesignLoadArgs.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nfpfw', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'pif_design_json', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'pif_config_json', 'BINARY', None, ),  # 3
)
all_structs.append(DesignLoadStatus)
DesignLoadStatus.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_loaded', None, None, ),  # 1
    (2, TType.STRING, 'uuid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'frontend_build_date', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'frontend_source', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'frontend_version', 'UTF8', None, ),  # 5
    (6, TType.I64, 'uptime', None, None, ),  # 6
)
all_structs.append(RegisterArrayArg)
RegisterArrayArg.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'reg_id', None, None, ),  # 1
    (2, TType.I32, 'index', None, None, ),  # 2
    (3, TType.I32, 'count', None, None, ),  # 3
)
all_structs.append(RegisterFieldDesc)
RegisterFieldDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'width', None, None, ),  # 2
)
all_structs.append(RegisterDesc)
RegisterDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'id', None, None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
    (4, TType.I32, 'count', None, None, ),  # 4
    (5, TType.STRING, 'table', 'UTF8', None, ),  # 5
    (6, TType.I32, 'tableid', None, None, ),  # 6
    (7, TType.LIST, 'fields', (TType.STRUCT, [RegisterFieldDesc, None], False), None, ),  # 7
)
all_structs.append(P4CounterDesc)
P4CounterDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'id', None, None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
    (4, TType.I32, 'count', None, None, ),  # 4
    (5, TType.STRING, 'table', 'UTF8', None, ),  # 5
    (6, TType.I32, 'tableid', None, None, ),  # 6
    (7, TType.I32, 'width', None, None, ),  # 7
)
all_structs.append(SysCounterValue)
SysCounterValue.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'id', None, None, ),  # 2
    (3, TType.STRUCT, 'value', [RteValue, None], None, ),  # 3
)
all_structs.append(P4CounterReturn)
P4CounterReturn.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)
all_structs.append(TableEntry)
TableEntry.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'rule_name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'default_rule', None, None, ),  # 2
    (3, TType.STRING, 'match', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'actions', 'BINARY', None, ),  # 4
    (5, TType.I32, 'priority', None, None, ),  # 5
)
all_structs.append(TableDesc)
TableDesc.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tbl_id', None, None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'tbl_entries_max', None, None, ),  # 3
)
all_structs.append(McastCfgEntry)
McastCfgEntry.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'group_id', None, None, ),  # 1
    (2, TType.I32, 'max_entries', None, None, ),  # 2
    (3, TType.LIST, 'ports', (TType.I32, None, False), None, ),  # 3
)
all_structs.append(PortInfo)
PortInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.STRING, 'token', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'info', 'UTF8', None, ),  # 3
)
all_structs.append(ParserValueSetFieldDesc)
ParserValueSetFieldDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'width', None, None, ),  # 2
)
all_structs.append(ParserValueSetEntry)
ParserValueSetEntry.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mask', 'UTF8', None, ),  # 2
)
all_structs.append(ParserValueSetDesc)
ParserValueSetDesc.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'pvs_id', None, None, ),  # 1
    (2, TType.STRING, 'pvs_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'pvs_entries_max', None, None, ),  # 3
    (4, TType.LIST, 'key_layout', (TType.STRUCT, [ParserValueSetFieldDesc, None], False), None, ),  # 4
)
all_structs.append(MeterCfg)
MeterCfg.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'rate_k', None, None, ),  # 1
    (2, TType.I32, 'burst_k', None, None, ),  # 2
    (3, TType.I32, 'array_offset', None, None, ),  # 3
    (4, TType.I32, 'count', None, None, ),  # 4
)
all_structs.append(MeterDesc)
MeterDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'id', None, None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
    (4, TType.I32, 'mclass', None, None, ),  # 4
    (5, TType.I32, 'count', None, None, ),  # 5
    (6, TType.STRING, 'table', 'UTF8', None, ),  # 6
    (7, TType.I32, 'tableid', None, None, ),  # 7
)
all_structs.append(DigestFieldDesc)
DigestFieldDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'width', None, None, ),  # 2
)
all_structs.append(DigestDesc)
DigestDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'id', None, None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
    (4, TType.STRING, 'field_list_name', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'fields', (TType.STRUCT, [DigestFieldDesc, None], False), None, ),  # 5
)
all_structs.append(DebugCtlReturn)
DebugCtlReturn.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'return_value', None, None, ),  # 1
    (2, TType.STRING, 'return_data', 'BINARY', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
